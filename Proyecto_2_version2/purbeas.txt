# Import standard python modules.
import sys
import time
import serial

# This example uses the MQTTClient instead of the REST client
from Adafruit_IO import MQTTClient
from Adafruit_IO import Client, Feed

# holds the count for the feed
run_count = 0

# Set to your Adafruit IO username and key.
# Remember, your key is a secret,
# so make sure not to publish it when you publish this code!
ADAFRUIT_IO_USERNAME = "Mar23599"
ADAFRUIT_IO_KEY = "aio_RXPm314Emly7tcg2QsMeyxWDKkbr"

# Set to the ID of the feed to subscribe to for updates.
FEED_ID_EEPROM = 'EPROM_control'
FEED_ID_S1 = 'Servo1_TX'
FEED_ID_S2 = 'Servo2_TX'
FEED_ID_S3 = 'Servo3_TX'
FEED_ID_S4 = 'Servo4_TX'
FEED_ID_CONFIRM = 'CONFIRM_F'

# Define "callback" functions which will be called when certain events 
# happen (connected, disconnected, message arrived).
def connected(client):
    """Connected function will be called when the client is connected to
    Adafruit IO.This is a good place to subscribe to feed changes. The client
    parameter passed to this function is the Adafruit IO MQTT client so you
    can make calls against it easily.
    """
    # Subscribe to changes on feeds
    print('Subscribing to Feeds: EEPROM, Servo1-4')
    client.subscribe(FEED_ID_EEPROM)
    client.subscribe(FEED_ID_S1)
    client.subscribe(FEED_ID_S2)
    client.subscribe(FEED_ID_S3)
    client.subscribe(FEED_ID_S4)
    print('Waiting for feed data...')

def disconnected(client):
    """Disconnected function will be called when the client disconnects."""
    sys.exit(1)

def message(client, feed_id, payload):
    """Message function will be called when a subscribed feed has a new value.
    The feed_id parameter identifies the feed, and the payload parameter has
    the new value.
    """
    print('Feed {0} received new value: {1}'.format(feed_id, payload))
    
    # Determinar el formato del mensaje según el feed de origen
    if feed_id == FEED_ID_EEPROM:
        confirm_msg = f"EP:{payload}"
    elif feed_id == FEED_ID_S1:
        confirm_msg = f"S1:{payload}"
    elif feed_id == FEED_ID_S2:
        confirm_msg = f"S2:{payload}"
    elif feed_id == FEED_ID_S3:
        confirm_msg = f"S3:{payload}"
    elif feed_id == FEED_ID_S4:
        confirm_msg = f"S4:{payload}"
    else:
        confirm_msg = f"Unknown:{payload}"  # Opcional para feeds no esperados
    
    # Enviar confirmación al feed de confirmación (FEED_ID_CONFIRM se mantiene igual)
    print('Enviando confirmación:', confirm_msg)
    client.publish(FEED_ID_CONFIRM, confirm_msg)


# Create an MQTT client instance.
client = MQTTClient(ADAFRUIT_IO_USERNAME, ADAFRUIT_IO_KEY)

# Setup the callback functions defined above.
client.on_connect = connected
client.on_disconnect = disconnected
client.on_message = message

# Connect to the Adafruit IO server.
client.connect()

# The first option is to run a thread in the background so you can continue
# doing things in your program.
client.loop_background()

while True:
    print('Running "main loop"')
    time.sleep(3)






ISR(USART_RX_vect) {
	static uint8_t buffer[10]; // Buffer para almacenar los datos recibidos
	static uint8_t index = 0;  // Índice del buffer
	static uint8_t receiving = 0; // Flag para indicar que estamos recibiendo datos
	
	uint8_t received = UDR0; // Leer el byte recibido
	
	if (received == '\n' || received == '\r') {
		// Fin de comando, procesar el buffer
		buffer[index] = '\0'; // Terminar la cadena
		
		if (contador_modo == 1) {
			// Modo 1: Esperando EXACTAMENTE el formato "EP:d" donde d es 0, 1 o 2
			if (index == 4 && // Longitud exacta del comando
			buffer[0] == 'E' &&
			buffer[1] == 'P' &&
			buffer[2] == ':' &&
			buffer[3] >= '0' &&
			buffer[3] <= '2') {
				
				opcion = buffer[3] - '0'; // Convertir ASCII a número (0-2)
				flag_control_EPROM = 1; // Activar flag para procesar en main
				
				// Enviar confirmación
				UART_putstring("EPROM_OK\n");
			}
			// Cualquier otro comando en modo 1 será ignorado
		}
		else if (contador_modo == 2) {
			// Modo 2: Esperando formato "Sn:dato" (MANTENIDO SIN CAMBIOS)
			if (buffer[0] == 'S' && buffer[2] == ':') {
				uint8_t servo_num = buffer[1] - '0'; // Obtener número de servo
				
				if (servo_num >= 1 && servo_num <= 4) {
					uint8_t value = 0;
					uint8_t i = 3;
					
					// Convertir los dígitos ASCII a número
					while (buffer[i] >= '0' && buffer[i] <= '9') {
						value = value * 10 + (buffer[i] - '0');
						i++;
					}
					
					if (value <= 255) { // Asegurar que es un uint8_t válido
						servo_data[servo_num - 1] = value;
						
						// Opcional: enviar confirmación
						char confirm[20];
						sprintf(confirm, "S%d_OK\n", servo_num);
						UART_putstring(confirm);
					}
				}
			}
		}
		
		// Reiniciar para el próximo comando
		index = 0;
		receiving = 0;
	}
	else {
		// Almacenar el byte en el buffer si hay espacio
		if (index < sizeof(buffer) - 1) {
			buffer[index++] = received;
			} else {
			// Buffer lleno, descartar datos
			index = 0;
		}
	}
}